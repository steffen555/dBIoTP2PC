

The system consists of two scripts:

wotds.py: contains the WoT-DataStorage layer and the underlying Kademlia
layer. The majority of our code resides here. The script start_script.py makes
it easy to launch several instances of wotds.py, simulating several nodes
connected to the network.

sensors.py: contains code that collects sensor data and serves it via a web
API. This script should be run at most once per Raspberry Pi. It should run
after wotds.py, since it connects to one of the nodes.



To run the system:

In one terminal, run:

	python2 start_script.py

This launches multiple instances of wotds.py around port 5000.

In another terminal, run:

	python2 sensors.py

This connects to the node on port 5000, which finds the responsible node and
assigns responsibility to it with the help of the Kademlia layer. Data will
then be periodically fetched and stored in the network through the web API.



To manually run the wotds.py script, the usage is as follows:

	python2 wotds.py <port>
		launches a lone node which does not connect anywhere

	python2 wotds.py <own port> <remote IP> <remote port>
		launches a node which joins the network by connecting to the given ip
		and port



Internally, the scripts use the following API:

Kademlia layer:

GET /api/kademlia/id/

	Implements the 
GET /api/kademlia/closest_nodes/<int:node_id>/
POST /api/kademlia/values/


WoTDS layer:
	
GET /api/wotds/responsibility/
GET /api/wotds/registration/
POST /api/wotds/datapoints/
GET /api/kademlia/values/


Sensor data layer:


GET /pi/sensors/temperature/0/
GET /pi/sensors/humidity/0/
GET /pi/sensors/motion/0/
POST /pi/actuators/leds/0/









........... old below ............

main.py is the main script. It is supposed to be run on the command line.

The first argument to main.py is the port number on which to run the peer. Two
more arguments, an IP address and a port, may optionally be given. If they are
given, they will be used as the initial peer in the network.

After running main.py, a web interface is available on the local machine on
the given port.


The system can also be accessed programatically via the following API:

--- PUT /api/kademlia/nodes/MY_ID/ ---

This implements the PING command of Kademlia. It is used to add the sender to
the recipient's buckets list. MY_ID must be a decimal integer representing the
sender's node ID. The sender's port number is given as the "port" parameter in
the HTTP request body.


--- GET /api/kademlia/closest_nodes/NODE_ID/ ---

This implements the FIND_NODE command of Kademlia. It is used to find the k
closest nodes to NODE_ID. The result is a list of up to k triples of
(ip_address, port, node_id) represented as JSON.





Other notes:
- we use Flask as our web server
- we use the Python Requests module as HTTP client
- we use the built-in Python JSON module to jsonify data in FIND_NODE
- the start_script.py file lets us automatically spawn a number of peers which
  connect to each other

